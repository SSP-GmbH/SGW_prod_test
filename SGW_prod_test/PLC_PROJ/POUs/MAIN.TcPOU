<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{cf7a1f3b-01b2-485c-af22-ebbbf99dfab4}" SpecialFunc="None">
    <Declaration><![CDATA[(* POUs/MAIN *)

PROGRAM MAIN
VAR
  // your serial machinery
  TxBuf    : ComBuffer;
  RxBuf    : ComBuffer;
  fbPort   : SerialLineControl;
  fbSend   : SendString;
  txBusy   : BOOL;

  // ramp parameters
  STEP_DELAY  : TIME := T#100MS;   // time between voltage‐steps
  HOLD_TIME   : TIME := T#1S;      // dwell at ends
  VOLT_MIN    : INT  := 1;         // lowest V
  VOLT_MAX    : INT  := 20;        // highest V

  // state
  state       : RAMP_STATES := RAMP_UP;
  currentVolt : INT          := VOLT_MIN;

  // two timers
  stepTimer   : TON := (PT := STEP_DELAY);
  holdTimer   : TON := (PT := HOLD_TIME);

  // send string
  txStr       : STRING(80);
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// — initialize buffers once —
IF NOT fbPort.initialized THEN
  TxBuf.RdIdx    := 0;  TxBuf.WrIdx    := 0;  TxBuf.Count    := 0;
  TxBuf.FreeByte := SIZEOF(TxBuf.Buffer); TxBuf.Error := 0; TxBuf.blocked := FALSE;

  RxBuf.RdIdx    := 0;  RxBuf.WrIdx    := 0;  RxBuf.Count    := 0;
  RxBuf.FreeByte := SIZEOF(RxBuf.Buffer); RxBuf.Error := 0; RxBuf.blocked := FALSE;
END_IF

// — always drive the COM port FB —
fbPort(
  Mode      := SERIALLINEMODE_DEFAULT,
  pComIn    := ADR(GLOBAL_VARS.X003_In),
  pComOut   := ADR(GLOBAL_VARS.X003_Out),
  SizeComIn := SIZEOF(GLOBAL_VARS.X003_In),
  TxBuffer  := TxBuf,
  RxBuffer  := RxBuf
);

// — step‐timer always running —  
stepTimer(IN := TRUE);

IF stepTimer.Q THEN
  // reset the step timer
  stepTimer(IN := FALSE);
  // advance or retract voltage
  CASE state OF
    RAMP_UP:
      IF currentVolt < VOLT_MAX THEN
        currentVolt := currentVolt + 1;
      ELSE
        // reached top → enter hold
        state := HOLD_HIGH;
        holdTimer(IN := TRUE);  // start the 1 s hold
      END_IF

    RAMP_DOWN:
      IF currentVolt > VOLT_MIN THEN
        currentVolt := currentVolt - 1;
      ELSE
        // reached bottom → enter hold
        state := HOLD_LOW;
        holdTimer(IN := TRUE);
      END_IF
  END_CASE

  // whenever we actually moved (or hit an end), send the new setpoint
  // build string “VSET1:xx.00”
  txStr := CONCAT(
             'VSET1:',
             CONCAT(
               INT_TO_STRING(currentVolt),
               '.00'
             )
           );
  fbSend(
    SendString := txStr,
    TxBuffer   := TxBuf,
    Busy       => txBusy
  );
END_IF

// — hold‐timer only active in HOLD_HIGH or HOLD_LOW —  
holdTimer(
  IN := (state = HOLD_HIGH) OR (state = HOLD_LOW)
);

IF holdTimer.Q THEN
  // reset hold
  holdTimer(IN := FALSE);

  // transition to next ramp direction
  IF state = HOLD_HIGH THEN
    state := RAMP_DOWN;
  ELSIF state = HOLD_LOW THEN
    state := RAMP_UP;
  END_IF
END_IF

// — (optional) map to your EL2008 outputs if you like —  
GLOBAL_VARS.DO_EL2008_0 := (state = RAMP_UP) OR (state = RAMP_DOWN);
GLOBAL_VARS.DO_EL2008_1 := NOT GLOBAL_VARS.DO_EL2008_0;]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>