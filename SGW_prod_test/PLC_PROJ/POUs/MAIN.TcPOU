<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{cf7a1f3b-01b2-485c-af22-ebbbf99dfab4}" SpecialFunc="None">
    <Declaration><![CDATA[(* POUs/MAIN *)

PROGRAM MAIN

VAR
  // 1) COM port & send machinery
  TxBuf      : ComBuffer;
  RxBuf      : ComBuffer;
  fbPort     : SerialLineControl;
  fbSend     : SendString;
  txBusy     : BOOL;

  // 2) Throttle sends
  sendTimer  : TON := (PT := T#100MS);
  canSend    : BOOL;

  // 3) Command
  queryBase  : STRING(16) := 'VSET1?';
  txStr      : STRING(20);

  // 4) ReceiveString FB & vars
  fbReceive       : ReceiveString;
  rxStr           : STRING(80);
  stringReceived  : BOOL;
  rxBusy          : BOOL;
  rxError         : ComError_t;
  rxTimeout       : BOOL;
  fbRecvReset     : BOOL := FALSE;

  // 5) Parsed result
  measuredVoltage : REAL := 0.0;

  // 6) Debounce outputs
  busyFilter   : TON := (PT := T#100MS);
  errorFilter  : TON := (PT := T#100MS);
  busyLong     : BOOL;
  errorLong    : BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[// — init COM buffers once —

//— A) Initialize COM buffers once —  
IF NOT fbPort.initialized THEN
  TxBuf.RdIdx    := 0;  TxBuf.WrIdx    := 0;  TxBuf.Count    := 0;
  TxBuf.FreeByte := SIZEOF(TxBuf.Buffer); TxBuf.Error := 0; TxBuf.blocked := FALSE;

  RxBuf.RdIdx    := 0;  RxBuf.WrIdx    := 0;  RxBuf.Count    := 0;
  RxBuf.FreeByte := SIZEOF(RxBuf.Buffer); RxBuf.Error := 0; RxBuf.blocked := FALSE;
END_IF


//— B) Always drive the SerialLineControl FB each scan —  
fbPort(  
  Mode      := SERIALLINEMODE_DEFAULT,  
  pComIn    := ADR(GLOBAL_VARS.X003_In),  
  pComOut   := ADR(GLOBAL_VARS.X003_Out),  
  SizeComIn := SIZEOF(GLOBAL_VARS.X003_In),  
  TxBuffer  := TxBuf,  
  RxBuffer  := RxBuf  
);  

//— C) Throttle sends via sendTimer —  
sendTimer(IN := TRUE);              // run the timer :contentReference[oaicite:11]{index=11}  
canSend := sendTimer.Q;             // TRUE when PT has elapsed  

//— D) If allowed, build command + CR and send —  
IF canSend THEN  
  sendTimer(IN := FALSE);           // reset the timer  

  // append ASCII 10 (LF) using CHR(10)
  txStr := CONCAT(queryBase, CHR(10));  

  fbSend(                           // send the command :contentReference[oaicite:12]{index=12}  
    SendString := txStr,  
    TxBuffer   := TxBuf,  
    Busy       => txBusy  
  );  

  // pulse Reset to arm ReceiveString for the incoming reply
  fbRecvReset := TRUE;  
END_IF  

//— E) Clear fbRecvReset once fbReceive goes busy —  
IF fbReceive.busy THEN  
  fbRecvReset := FALSE;             // only the rising edge matters :contentReference[oaicite:13]{index=13}  
END_IF  

//— F) Call ReceiveString to capture everything up to CR —  
fbReceive(  
  Prefix         := '',             // no prefix :contentReference[oaicite:14]{index=14}  
  Suffix         := CHR(10),        // terminate on LF :contentReference[oaicite:15]{index=15}  
  Timeout        := T#0MS,          // disable timeout when using suffix :contentReference[oaicite:16]{index=16}  
  Reset          := fbRecvReset,    // start new reception :contentReference[oaicite:17]{index=17}  
  ReceivedString := rxStr,          // in-out :contentReference[oaicite:18]{index=18}  
  RXbuffer       := RxBuf,          // in-out :contentReference[oaicite:19]{index=19}  
  StringReceived => stringReceived, // output :contentReference[oaicite:20]{index=20}  
  busy           => rxBusy,         // output :contentReference[oaicite:21]{index=21}  
  Error          => rxError,        // output :contentReference[oaicite:22]{index=22}  
  RxTimeout      => rxTimeout       // output :contentReference[oaicite:23]{index=23}  
);  

//— G) When a full line arrives, parse it —  
IF stringReceived THEN  
  // ASCII “xx.yy” → REAL  
  measuredVoltage := STRING_TO_REAL(rxStr);  
END_IF;  

//— H) Debounce busy/error for DOs —  
busyFilter(IN := txBusy);  
errorFilter(IN := (rxError <> COMERROR_NOERROR));  // any non-zero code is an error  

busyLong  := busyFilter.Q;  
errorLong := errorFilter.Q;  

//— I) Drive EL2008 channels from the filtered flags —  
GLOBAL_VARS.DO_EL2008_RELAY_0 := NOT busyLong;      // high when ready  
GLOBAL_VARS.DO_EL2008_RELAY_1 := errorLong;         // high when fault  
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>