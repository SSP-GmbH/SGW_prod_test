<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{cf7a1f3b-01b2-485c-af22-ebbbf99dfab4}" SpecialFunc="None">
    <Declaration><![CDATA[(* POUs/MAIN *)

PROGRAM MAIN
VAR
	CanRx          : CAN_IFACE_QUEUE;
	CanTx          : CAN_IFACE_QUEUE;
	i              : UINT;
	slotIn         : CAN_MsgSlot;
	slotOut        : CAN_MsgSlot;
	msgIn          : CAN_MSG;
	msgOut         : CAN_MSG;

	rawVoltIn      : UINT := 0;
	rawVoltOut     : UINT := 0;
	rawCurrentIn   : UINT := 0;
	rawCurrentOut  : UINT := 0;

	physVoltIn     : REAL := 0.0;
	physVoltOut    : REAL := 0.0;
	physCurrentIn  : REAL := 0.0;
	physCurrentOut : REAL := 0.0;

	FB_PSU         : FB_PowerSupply;

	JUST_PSU       : BOOL := FALSE;
	SOME_FLAG      : BOOL := FALSE;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
FB_PSU.Cycle();

IF JUST_PSU AND SOME_FLAG THEN

	FB_PSU.SetVoltage(volts := physVoltIn);
	SOME_FLAG := FALSE;

ELSE
	// 1) Read the hardware Rx shadow
	CanRx := EL6751_GVLs.gCanIf_RxMsg;
	
	// 2) Process all received messages
	IF CanRx.NoOfMessages > 0 THEN
		// Prepare Tx queue index
		FOR i := 0 TO CanRx.NoOfMessages - 1 DO
	
			slotIn := CanRx.Messages[i];
			msgIn := F_ParseSlot(slot := slotIn);
	
			// Route by ID
			CASE msgIn.ID OF
	
			16#200:  // Set voltage command
				IF msgIn.DLC = 2 THEN // Expect DLC = 2
					rawVoltOut := BytesToUInt16(highByte := msgIn.DATA[1], lowByte := msgIn.DATA[0]);
					physVoltOut := RawToVoltage(raw := rawVoltOut);
					FB_PSU.SetVoltage(volts := physVoltOut);
				END_IF;

			16#300:  // Set current command
				IF msgIn.DLC = 2 THEN
					rawCurrentOut := SHL(TO_UINT(msgIn.DATA[0]), 8) OR TO_UINT(msgIn.DATA[1]);
					physCurrentOut := RawToCurrent(raw := rawCurrentOut);
					FB_PSU.SetCurrent(amps := physCurrentOut);
				END_IF;
	
			// You could also handle GetVoltage (0x210) or GetCurrent (0x310)
			// by reading back right away and sending feedback
			END_CASE;

			// --- Prepare feedback: voltage at 0x201, current at 0x301 ---
			// 3A) Read back voltage and compose 0x201
			msgOut.ID  := 16#201;
			msgOut.DLC := 2;
			msgOut.DATA[1] := TO_BYTE(SHR(rawVoltIn, 8));   // MSB
			msgOut.DATA[0] := TO_BYTE(rawVoltIn AND 16#FF); // LSB
			slotOut := F_ComposeSlot(msg := msgOut);
			CanTx.Messages[i*2 + 0] := slotOut;

			// 3B) Read back current and compose 0x301
			msgOut.ID  := 16#301;
			msgOut.DLC := 2;
			msgOut.DATA[1] := TO_BYTE(SHR(rawCurrentIn, 8));
			msgOut.DATA[0] := TO_BYTE(rawCurrentIn AND 16#FF);
			slotOut := F_ComposeSlot(msg := msgOut);
			CanTx.Messages[i*2 + 1] := slotOut;
		END_FOR

	// 4) Finalize Tx queue
	// Number of slots used = 2 × received commands
	CanTx.NoOfMessages := CanRx.NoOfMessages * 2;
	CanTx.TxCounter := CanTx.TxCounter + 1;
	END_IF

	physVoltIn := FB_PSU.GetVoltage();
	rawVoltIn := VoltageToRaw(volts := physVoltIn);
	physCurrentIn := FB_PSU.GetCurrent();
	rawCurrentIn := CurrentToRaw(amps := physCurrentIn);

// 5) Write back to hardware shadow
EL6751_GVLs.gCanIf_TxMsg := CanTx;

END_IF]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>